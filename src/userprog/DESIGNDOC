           +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----


>> Fill in the names and email addresses of your group members.

JuHyeon Jang	 <cjdool@kaist.ac.kr>
Dongeon Kim		 <dongeon97@kaist.ac.kr>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

   Signal handler

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

  <threads/thread.h>

    #define FDT_SIZE 128                     /* File Descriptor Table Size. */
    #define SIG_MAX 10
    
    struct sig {
        int num;
        void * sighandler;
    };

    struct thread {

        ...

        struct file *fdt[FDT_SIZE];         /* File Descriptor Table */
        int next_fd;                        /* Next file descriptor */

        struct thread * parent;             /* parent thread */
        struct list child_list;             /* child thread list */
        struct list_elem child_elem;        /* child list element */
        struct semaphore wait_sema;         /* wait until child process exit */ 
        struct semaphore load_sema;         /* wait until child process loaded */
        struct semaphore exit_sema;         /* wait until parent process get child's status */
        int wait_on;                        /* which pid thread waits on*/
        int exit_status;                    /* Exit status */
        int load_status;                    /* Load status */
        int by_exit;                        /* exit by exit() system call */

        struct sig sig[SIG_MAX];            /* Table for signal handling */

        ...
    }

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

    syscall.c 파일 내의 get_argument() 함수에서, user stack을 가리키는 esp로부터
    system call parameter의 개수만큼 stack에서 data를 kernel로 가져옴
    가져올 때 user address인지 check_address()함수를 통해 모두 check함


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?



>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

    parent process                  child process

    process_wait(child_tid)
        sema_down( &wait_sema )     ...
                                    ...
                                    thread_exit()
                                        sema_up( &wait_sema)
        ...                             sema_down( &exit_sema)
        get child status
        sema_up( &exit_sema)            ...
                                        ...
                                    
                                    process terminate


    tid를 parameter로 받아서 process_wait()함수 실행
    tid가 음수이거나, 현재 process의 child가 아니거나, 이미 wait에 들어왔던 tid라면
    return -1을 함
    예외 조건이 아니면 semaphore를 이용해서 child process가 exit할 때까지 block된다
    child가 exit할 때 sema_up을 해주면서 process_wait이 다시 진행됨
    이때 child process의 종료 상태를 확인해야하므로 child를 sema_down을 통해 대기시키고 
    child의 종료상태를 가져온 후에 sema_up을 해준다. child의 종료상태를 return함

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

    system call을 실행할 때 user영역을 가리키는 esp 와 각 system call의 argument
    개수만큼 data를 받아올 때 모두 valid address인지 check함
    잘못된 영역을 참조했을 경우, exit(-1)을 실행하는데 exit system call에서
    모든 resource를 free해줌 

--- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

   child process가 create된 후 child tid값을 받아서 child가 start_process() 함수에서
   load가 끝날때까지 semaphore를 사용해서 대기한다.
   load가 끝나면 child의 load_status에 load의 성공유무를 저장하고 
   parent process에서 그 값을 받아온 후 return한다.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

    - P calls wait(C) before C exits
        semaphore를 사용해서 C가 종료할 때까지 P가 대기
        race condition 없음, exit system call에서 모든 resource free해줌
    
    - P calls wait(C) after C exits
        P의 childlist에 C가 없음 -> get_child_process(C) 함수 NULL return
        wait() -> return -1, exit system call에서 모든 resource free해줌

    - P terminates w/o waiting, before C exits
        C의 parent가 없음 -> race condition 없음         
        exit system call에서 모든 resource free해줌
        
    - P terminates w/o waiting, after C exits
        위와 동일함
        
---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

    불필요한 memory할당을 하지 않기 위해 page를 할당하여 user data를 받아오지 않고
    kernel stack으로 직접 받아옴

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
